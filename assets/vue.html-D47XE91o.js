import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,o as l,b as i}from"./app-D0fcLRg9.js";const r={},a=i('<h2 id="v-model-的原理是什么" tabindex="-1"><a class="header-anchor" href="#v-model-的原理是什么"><span>v-model 的原理是什么？</span></a></h2><p>Vue 的双向数据绑定是由数据劫持结合发布者订阅者实现的。</p><p>数据劫持是通过 Object.defineProperty()来劫持对象数据的 setter 和 getter 操作。在数据变动时作你想做的事</p><ul><li><p>原理：</p><ul><li><p>通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化-&gt;视图更新</p></li><li><p>在初始化 vue 实例时，遍历 data 这个对象，给每一个键值对利用 Object.definedProperty 对 data 的键值对新增 get 和 set 方法</p></li><li><p>利用了事件监听 DOM 的机制，让视图去改变数据</p></li></ul></li></ul><h2 id="vue重写了那些数组方法" tabindex="-1"><a class="header-anchor" href="#vue重写了那些数组方法"><span>vue重写了那些数组方法</span></a></h2><p>LRWYGCFS4NC412952</p><ul><li>&#39;push&#39;：尾部插入</li><li>&#39;pop&#39;：删除并返回最后一个元素</li><li>&#39;shift&#39;：删除并返回头部元素</li><li>&#39;unshift&#39;：头部插入</li><li>&#39;splice&#39;：截取数组</li><li>&#39;sort&#39;：数组排序</li><li>&#39;reverse&#39;：反转数组</li></ul><p><mark>使用这7种以外的数组方法更新数组，且需要视图也更新，则需要使用this.$set。</mark></p><h2 id="vue-生命周期" tabindex="-1"><a class="header-anchor" href="#vue-生命周期"><span>vue 生命周期</span></a></h2><ul><li><p><strong>beforeCreate：</strong> vue 实例的挂载元素 el 和数据对象 data 都是 undefined，还没有初始化。</p></li><li><p><strong>created：</strong> vue 实例的数据对象 data 有了，可以访问里面的数据和方法，未挂载到 DOM，el 还没有</p></li><li><p><strong>beforeMount：</strong> vue 实例的 el 和 data 都初始化了，但是挂载之前为虚拟的 dom 节点</p></li><li><p><strong>mounted：</strong> vue 实例挂载到真实 DOM 上，就可以通过 DOM 获取 DOM 节点</p></li><li><p><strong>beforeUpdate：</strong> 响应式数据更新时调用，发生在虚拟 DOM 打补丁之前，适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器</p></li><li><p><strong>updated：</strong> 虚拟 DOM 重新渲染和打补丁之后调用，组成新的 DOM 已经更新，避免在这个钩子函数中操作数据，防止死循环</p></li><li><p><strong>beforeDestroy：</strong> 实例销毁前调用，实例还可以用，this 能获取到实例，常用于销毁定时器，解绑事件</p></li><li><p><strong>destroyed：</strong> 实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</p></li></ul><h2 id="vue-路由的两种模式" tabindex="-1"><a class="header-anchor" href="#vue-路由的两种模式"><span>vue 路由的两种模式</span></a></h2><ul><li>hash：即地址栏 URL 中的#符号（此 hsah 不是密码学里的散列运算） <ul><li>改变 hash 不会重新加载页面，hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响。</li></ul></li><li>history：利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法 <ul><li>这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。</li></ul></li></ul><h3 id="vue的data为什么是个函数" tabindex="-1"><a class="header-anchor" href="#vue的data为什么是个函数"><span>vue的data为什么是个函数</span></a></h3><p>JS中只有函数能构成作用域，所以用函数可以使每个实例的data作用域相互独立</p><h2 id="v-for-中的-key-有什么作用" tabindex="-1"><a class="header-anchor" href="#v-for-中的-key-有什么作用"><span>v-for 中的 key 有什么作用</span></a></h2><h2 id="vue-的自定义指令怎么渲染的" tabindex="-1"><a class="header-anchor" href="#vue-的自定义指令怎么渲染的"><span>vue 的自定义指令怎么渲染的</span></a></h2><h2 id="什么是单文件组件" tabindex="-1"><a class="header-anchor" href="#什么是单文件组件"><span>什么是单文件组件</span></a></h2><p>简单来说，就是将html，css，js写在同一个vue文件中的文件，被称为单文件组件</p><p>它可以被看做是一个组件，因此可以被其他组件引用，这就是模块化</p>',19),n=[a];function o(p,s){return l(),t("div",null,n)}const h=e(r,[["render",o],["__file","vue.html.vue"]]),c=JSON.parse('{"path":"/docs/interview/vue/vue.html","title":"vue2面试点","lang":"zh-CN","frontmatter":{"title":"vue2面试点","date":"2022-06-21T00:00:00.000Z","description":"v-model 的原理是什么？ Vue 的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过 Object.defineProperty()来劫持对象数据的 setter 和 getter 操作。在数据变动时作你想做的事 原理： 通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用...","head":[["meta",{"property":"og:url","content":"https://bzt2017.github.io/docs/interview/vue/vue.html"}],["meta",{"property":"og:site_name","content":"Tiger"}],["meta",{"property":"og:title","content":"vue2面试点"}],["meta",{"property":"og:description","content":"v-model 的原理是什么？ Vue 的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过 Object.defineProperty()来劫持对象数据的 setter 和 getter 操作。在数据变动时作你想做的事 原理： 通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-25T10:55:16.000Z"}],["meta",{"property":"article:author","content":"Tiger"}],["meta",{"property":"article:published_time","content":"2022-06-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-06-25T10:55:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"vue2面试点\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-06-21T00:00:00.000Z\\",\\"dateModified\\":\\"2024-06-25T10:55:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Tiger\\",\\"url\\":\\"https://bzt2017.github.io/myBlog/\\"}]}"]]},"headers":[{"level":2,"title":"v-model 的原理是什么？","slug":"v-model-的原理是什么","link":"#v-model-的原理是什么","children":[]},{"level":2,"title":"vue重写了那些数组方法","slug":"vue重写了那些数组方法","link":"#vue重写了那些数组方法","children":[]},{"level":2,"title":"vue 生命周期","slug":"vue-生命周期","link":"#vue-生命周期","children":[]},{"level":2,"title":"vue 路由的两种模式","slug":"vue-路由的两种模式","link":"#vue-路由的两种模式","children":[{"level":3,"title":"vue的data为什么是个函数","slug":"vue的data为什么是个函数","link":"#vue的data为什么是个函数","children":[]}]},{"level":2,"title":"v-for 中的 key 有什么作用","slug":"v-for-中的-key-有什么作用","link":"#v-for-中的-key-有什么作用","children":[]},{"level":2,"title":"vue 的自定义指令怎么渲染的","slug":"vue-的自定义指令怎么渲染的","link":"#vue-的自定义指令怎么渲染的","children":[]},{"level":2,"title":"什么是单文件组件","slug":"什么是单文件组件","link":"#什么是单文件组件","children":[]}],"git":{"createdTime":1715939602000,"updatedTime":1719312916000,"contributors":[{"name":"tiger-github","email":"634513456@qq.com","commits":1}]},"readingTime":{"minutes":2.82,"words":845},"filePathRelative":"docs/interview/vue/vue.md","localizedDate":"2022年6月21日","excerpt":"<h2>v-model 的原理是什么？</h2>\\n<p>Vue 的双向数据绑定是由数据劫持结合发布者订阅者实现的。</p>\\n<p>数据劫持是通过 Object.defineProperty()来劫持对象数据的 setter 和 getter 操作。在数据变动时作你想做的事</p>\\n<ul>\\n<li>\\n<p>原理：</p>\\n<ul>\\n<li>\\n<p>通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化-&gt;视图更新</p>\\n</li>\\n<li>\\n<p>在初始化 vue 实例时，遍历 data 这个对象，给每一个键值对利用 Object.definedProperty 对 data 的键值对新增 get 和 set 方法</p>\\n</li>\\n<li>\\n<p>利用了事件监听 DOM 的机制，让视图去改变数据</p>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{h as comp,c as data};
